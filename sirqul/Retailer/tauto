#!/usr/bin/python
import yaml
import sys
import requests
import json


def get_item_from_dict(m_dict, tree_list):
  real_length = len(tree_list) - 1
  if real_length == 1:
      return m_dict[tree_list[0]]
  elif real_length == 2:
      return m_dict[tree_list[0]][tree_list[1]]
  elif real_length == 3:
      return m_dict[tree_list[0]][tree_list[1]][tree_list[2]]
  elif real_length == 4:
      return m_dict[tree_list[0]][tree_list[1]][tree_list[2]][tree_list[3]]
  else:
      raise Exception("The Next step depends in a 5th level variable, wich is not supported.")

class Step(object):
  """docstring for Step"""
  def __init__(self, url, headers, data, ordinal, dependencies=None, confirm_output=False):

    self.url = url
    self.headers = headers
    self.data = data
    self.ordinal = ordinal

    self.dependencies = dependencies
    self.confirm_output = confirm_output

  def execute(self, input_dict):
    # print self.dependencies
    if self.dependencies != None:
        # print self.dependencies
        self.data[self.dependencies[-1]] = get_item_from_dict(input_dict, self.dependencies)

        # print "===="
        # print self.data
        # print "===="
            
    response = requests.post(self.url, data=self.data, headers=self.headers, verify=False)

    return json.loads(response.content)
    
class Restautomator(object):
  def __init__(self):
    self.GLOBAL_YAML = "global.yaml"        
    self.yaml_file = sys.argv[1]

    self.steps = []

    self.assert_key = None # what key to look for to assert on output_dict
    self.assert_value = None # what value to expect from output_dict[self.assert_key]
    self.on_assert_error_key = None # what key to grab from out dict if error
  
  # def get_url(self, base_url, contents, step, constants):
  #   entry_point = contents[step]["details"]["entry_point"]

  #   if type(entry_point) == str:
  #     return base_url + entry_point
  #   else:
  #     return base_url + constants["entry_point"]

  def get_data(self, global_data, contents, step, constants):
    dirty_data = contents[step]["data"]
    clean_data = {}
    for key in dirty_data:
      if type(dirty_data[key]) is str:
        clean_data[key] = dirty_data[key]
      else:
        # clean_data[key] = 
        for k in dirty_data[key]:
          clean_data[key] = constants[dirty_data[key][k]]
        
    return clean_data

  def get_headers(self, global_data, contents, step, constants):



  def load(self):
    # load Global YAML
    with open(self.GLOBAL_YAML, "r") as yaml_global:
        contents = yaml.load(yaml_global)

    base_url = contents["base_url"]
    headers = contents["headers"]
    global_data = contents["data"]
    constants = contents["constants"]

    # load Custom YAML
    with open(self.yaml_file, "r") as yaml_custom:
        contents = yaml.load(yaml_custom)

    self.assert_key = contents["assert"]["key"]
    self.assert_value = contents["assert"]["value"]

    for step in contents:
      if step == "assert":
          continue

      url = base_url + contents[step]["details"]["entry_point"]
      ordinal = contents[step]["details"]["ordinal"]

      data = self.get_data(global_data, contents, step, constants)
      
      dependencies = None

      if "dependencies" in contents[step]:
          dependencies = contents[step]["dependencies"]

      if "headers" in contents[step]:
          headers.update(contents[step]["headers"])

      confirm_output = False
      if "confirm_output" in contents[step]["details"]:
          confirm_output = contents[step]["details"]["confirm_output"]

      self.steps.append(Step(url, headers, data, ordinal, dependencies, confirm_output))
  
  # def order(self):
  def sort(self):
    for i in range(1,len(self.steps)):    
      j = i
      while j > 0 and self.steps[j].ordinal < self.steps[j-1].ordinal:
        self.steps[j], self.steps[j-1] = self.steps[j-1], self.steps[j]
        j-=1 

  def perform(self, step_index, input_dict):
      if step_index >= len(self.steps):
        return input_dict
      else:
        output = self.steps[step_index].execute(input_dict)

        if self.steps[step_index].confirm_output:
          self.confirm_current_step_output(self.steps[step_index], output)
        return self.perform(step_index+1, output)
  
  def confirm_current_step_output(self, Step, output):
      print ">>> Step %s OUTPUT for  in sequence: \n\t%s" % (Step.ordinal, output)
      print "-"*50

  def check_output(self, output):
      if output[self.assert_key] == self.assert_value:
        print "."
      elif self.on_assert_error_key != None:
        try:
            print output[self.on_assert_error_key]
        except:
            print output
      else:
        print "Error, type: False-Assertion. FINAL OUTPUT %s" % (json.dumps(output))

if __name__ == "__main__":
    tauto = Restautomator()
    tauto.load()
    tauto.sort()
    
    out = tauto.perform(0, None)

    tauto.check_output(out)
