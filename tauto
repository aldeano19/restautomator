#!/usr/bin/python
# release 1.0 - Beta
# Eriel Marimon - August 8, 2016
# tauto, a yaml based REST API testing tool

# /**
#  * Copyright (c) 2016 TestCaseCentral
#  * Licensed under Apache License, Version 2.0
#  * http://www.apache.org/licenses/LICENSE-2.0.txt
#  */
"""
 TODO:
 1. Add assertions of comparisons. ex: expected: > 4
"""


import yaml
import os, sys
import requests
import json
import datetime

def check_and_perform_operations(value_to_modify, dict_to_check):
  if "+" in dict_to_check and \
    (type(dict_to_check["+"]) == int or \
      type(dict_to_check["+"]) == float):
        value_to_modify += dict_to_check["+"]
  elif "-" in dict_to_check and \
    (type(dict_to_check["-"]) == int or \
      type(dict_to_check["-"]) == float):
        value_to_modify -= dict_to_check["-"]
  elif "multiply" in dict_to_check and \
    (type(dict_to_check["multiply"]) == int or \
      type(dict_to_check["multiply"]) == float):
        value_to_modify *= dict_to_check["multiply"]
  elif "divide" in dict_to_check and \
    (type(dict_to_check["divide"]) == int or \
      type(dict_to_check["divide"]) == float):
        value_to_modify /= dict_to_check["divide"]

  return value_to_modify

def has_embeded_list(the_list):
  for i in range(len(the_list)):
    if type(the_list[i]) == list:
      return i

def get_item_from_dict(m_dict, tree_list):
  i = 0
  while i < len(tree_list) - 1:
    m_dict = m_dict[tree_list[i]]
    i += 1
  return m_dict

# descends down a dictionary using key (which can ba a list of keys where every item corresponds to a lower level of the dictionary). If at some point it encounters a list of objects rather than a simple object, it will loop over that list, that would be the last level it can check, the final key should be there. returns a list of results
def get_val_from_dict(key, out_dict):
  output = []
  if type(key) == str:
    return out_dict[key]
  elif type(key) == list:
    for level in key: # start walking down the dictionary to get to the final 
                      #key
      if type(level) == str:
        out_dict = out_dict[level]
        if type(out_dict) != dict:
          output = out_dict
      elif type(level) == list:
        for item in out_dict:
          output.append(item[level[0]])
  return output

class AssertionFailedException(Exception):
    def __init__(self,*args,**kwargs):
        Exception.__init__(self,*args,**kwargs)

class NoInputException(Exception):
    def __init__(self,*args,**kwargs):
        Exception.__init__(self,*args,**kwargs)

class TautoAssertion(object):
  def __init__(self, key, expected, on_error_key, silent=False, fail=False):
    self.key = key
    self.expected = expected
    self.on_error_key = on_error_key

    self.silent = silent

    self.fail = fail

  def do(self, out_dict):
    if self.fail:
      print "e. Forced Failure"
    elif type(self.key) == str:
      if self.key not in out_dict:
        print "ERROR - KEY '%s' DOES NOT EXISTS IN %s" % (self.key, json.dumps(out_dict))
      elif out_dict[self.key] == self.expected:
        if self.silent:
          return
        print "."
      elif self.on_error_key not in [None, ""]:
        try:
          print "error on key:\n\texpected = %s.\n\tresult = %s\n\ton_error_key = %s" % (self.expected, out_dict[self.key], out_dict[self.on_error_key])
        except:
          print "excepted on error key:", out_dict
      else:
        print "Error, type: False-Assertion. \n\texpected = %s.\n\tresult = %s" % (self.expected, out_dict[self.key])
    else: # in case the key is a list
      # This else: block should be revised, the first nested if: is correct but the elses in it might be redundant or misleading
      got = get_val_from_dict(self.key, out_dict)
      
      # if got is an int, do comparison. if is a list find val in list
      if (type(got) == list and self.expected in got)\
        or (type(got) in [int, str, unicode, bool] and self.expected == got):
        if self.silent:
          return
        print "."
      elif self.on_error_key != None:
        try:
          on_error_value = get_val_from_dict(self.on_error_key, out_dict)
          
          print "error:\n\texpected = %s\n\tresult = %s\n\t%s = %s" % (self.expected, got, self.on_error_key, on_error_value)

          # print self.expected == got
        except:
          print "Exepted on error key:", got
      else:
        print "Error, type: False-Assertion. FINAL OUTPUT %s" % (json.dumps(out_dict))


class Step(object):
  def __init__(self, url, headers, data, details):

    self.url = url
    self.headers = headers
    self.data = data

    self.title = details["title"]
    self.ordinal = details["ordinal"]
    self.dependencies = details["dependencies"]
    self.confirm_output = details["confirm_output"]
    self.write_output = details["write_output"]
    
    if not details["write_output"]:
      self.write_output = self.title

    self.read_input = details["read_input"]

    self.input_dict = None


    if type(self.read_input) == str and self.read_input != "":
      file_in = "/tmp/%s" % (self.read_input)
      with open(file_in, "r") as inp:
        self.input_dict = json.loads(inp.read())
    elif self.read_input:
      self.input_dict = {}
      for input_file in self.read_input:
        file_in = "/tmp/%s" % (input_file)
        with open(file_in, "r") as inp:
          self.input_dict[input_file] = json.loads(inp.read())


  def execute(self, input_dict):
    if self.dependencies != None:
      for d in self.dependencies:
        # continue
        if input_dict:
          self.data[d[-1]] = get_item_from_dict(input_dict, d)
        else:
          raise Exception("--- Input expected but not provided. Check the 'read_input' field. ---\n")

    response = requests.post(self.url, data=self.data, headers=self.headers, verify=False)

    if self.write_output != "":
      outputname = "/tmp/%s" % (self.write_output)
      with open(outputname, "w") as out:
        out.write(response.content)

    try:
      return json.loads(response.content)
    except:
      raise Exception(response.text)

class Restautomator(object):
  def __init__(self):
    self.GLOBAL_YAML = "global.yaml"
    self.steps = []
    self.assertions = None
    self.yaml_file = None

    # if the yaml file is not passed in it takes the first yaml file 
    if len(sys.argv) > 1:
      self.yaml_file = sys.argv[1]
    else:
      files = [f for f in os.listdir('.') if os.path.isfile(f)]
      for f in files:
        if os.path.splitext(f)[1] == ".yaml":
          self.yaml_file = f
          break
      if not self.yaml_file:
        exception_message = "No YAML file on %s." % (os.path.dirname(os.path.realpath("__file__")))
        raise Exception(exception_message)

  def get_data(self, global_data, contents, step, constants):
    dirty_data = {}
    if "data" in contents[step]:
      dirty_data = contents[step]["data"]

    clean_data = {}
    for key in dirty_data:
      # this makes sense of the data if it uses the global config vs if it has hard coded variables
      if type(dirty_data[key]) is not dict:
        clean_data[key] = dirty_data[key]
      elif "global_constants" in dirty_data[key] or \
        "global_constant" in dirty_data[key]:
          for k in dirty_data[key]:
            clean_data[key] = constants[dirty_data[key][k]]
      else:
        raise Exception("Bad value for data filed '%s'" % (key))
    
    merge_data = clean_data.copy()

    if global_data:
      merge_data.update(global_data)
    
    return merge_data

  def get_expected_from_file(self, expected):
    in_file = "/tmp/" + expected["file"]
    with open(in_file, "r") as inp:
      expected_input_dict = json.loads(inp.read())

    expected_val = get_val_from_dict(expected["key_lookup"], expected_input_dict)

    # Checks if calculations where requested and performs them
    expected_val = check_and_perform_operations(expected_val, expected)

    return expected_val

  def get_assertions(self, assertions, constants):
    assertion_list = []
    for asse in assertions:
      force_fail = False
      key = ""
      on_error_key = ""
      expected = ""
      silent = None

      if not assertions[asse]:
        force_fail = True
      else:
        key = assertions[asse]["key"]
        expected = assertions[asse]["expected"]

        if "on_error_key" in assertions[asse]:
          on_error_key = assertions[asse]["on_error_key"]

        if type(expected) not in [bool, int] and "global_constants" in expected:
          expected = constants[expected["global_constants"]]
        elif type(expected) == dict:
          expected = self.get_expected_from_file(expected)
        
        silent = False
        if "silent" in assertions[asse]:
          silent = assertions[asse]["silent"]

      assertion_list.append(TautoAssertion(key, expected, on_error_key, silent, fail=force_fail))
    
    return assertion_list

  def load(self):
    headers = {}
    global_data = {}
    constants = {}

    no_global = True
    
    if os.path.isfile(self.GLOBAL_YAML) \
    and os.path.getsize(self.GLOBAL_YAML) != 0:
      no_global = False
      # load Global YAML
      with open(self.GLOBAL_YAML, "r") as yaml_global:
          contents = yaml.load(yaml_global)

      if "base_url" in contents:
        base_url = contents["base_url"]

      if "headers" in contents:
        headers = contents["headers"]

      if "data" in contents:
        global_data = contents["data"]

      if "constants" in contents:
        constants = contents["constants"]

    # load Custom YAML
    with open(self.yaml_file, "r") as yaml_custom:
        contents = yaml.load(yaml_custom)

    if no_global:
      base_url = contents["base_url"]

    self.assertions = self.get_assertions(contents["assert"], constants)

    for step in contents:
      if step in ["assert", "base_url", "constants"]:
          continue

      details = {}

      if "details" in contents[step]:
        meta = contents[step]["details"]
      elif "meta" in contents[step]:
        meta = contents[step]["meta"]
      else:
        raise Exception("No meta info on YAML file.")

      url = base_url + meta["entry_point"]
      data = self.get_data(global_data, contents, step, constants)
      
      dependencies = None
      if "dependencies" in contents[step]:
          dependencies = contents[step]["dependencies"]

      if "headers" in contents[step]:
          headers.update(contents[step]["headers"])

      confirm_output = False
      if "confirm_output" in meta:
          confirm_output = meta["confirm_output"]

      write_output = ""
      if "write_output" in meta:
          write_output = meta["write_output"]

      read_input = ""
      if "read_input" in meta:
        read_input = meta["read_input"]

      details["title"] = step
      details["entry_point"] = meta["entry_point"]
      details["ordinal"] = meta["ordinal"]
      details["dependencies"] = dependencies
      details["confirm_output"] = confirm_output
      details["write_output"] = write_output
      details["read_input"] = read_input

      self.steps.append(Step(url, headers, data, details))
  
  # def order(self):
  def sort(self):
    for i in range(1,len(self.steps)):    
      j = i
      while j > 0 and self.steps[j].ordinal < self.steps[j-1].ordinal:
        self.steps[j], self.steps[j-1] = self.steps[j-1], self.steps[j]
        j-=1 

  # recursive function that performs all steps and returns the output of the last one
  def perform(self, step_index, input_dict):
    
    if step_index >= len(self.steps):
      # For mutiple steps or single independent(no need of input from other steps) step:
      return input_dict

    elif len(self.steps) == 1 and self.steps[step_index].input_dict != None:
      # If there is only one step and it may need input from file execute that step and return
      output = self.steps[step_index].execute(self.steps[step_index].input_dict)
      # if confirm_output flag is on then show output json to screen
      if self.steps[step_index].confirm_output:
        self.confirm_current_step_output(self.steps[step_index], output)
      return output

    else: # If there are more steps continue recursion

      output = self.steps[step_index].execute(input_dict)

      # if confirm_output flag is on then show output json to screen
      if self.steps[step_index].confirm_output:
        self.confirm_current_step_output(self.steps[step_index], output)
      return self.perform(step_index+1, output)
  
  def confirm_current_step_output(self, Step, output):
      print ">>> Step %s OUTPUT for  in sequence: \n\t%s" % (Step.ordinal, json.dumps(output))
      print "-"*50

if __name__ == "__main__":
    tauto = Restautomator()
    tauto.load()
    tauto.sort()

    out = None

    if len(sys.argv) > 2 and sys.argv[2] == "debug":
      out = tauto.perform(0, None)

    try:
      out = tauto.perform(0, None)
    except AssertionFailedException, e:
      print "e. ", e
    except Exception, e:
      print e
      print "Critical Error has occurred, if the above info is not helpful:"
      print "   - Verify your yaml config is right. Ex. check all the data variables are spelled correctly."
      print "   - Verify target server is running."

    if out:
      for assertion in tauto.assertions:
        assertion.do(out)